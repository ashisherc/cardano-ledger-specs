; Shelley Types

block =
  [ header
  , transaction_bodies         : [* transaction_body]
  , transaction_witness_sets   : [* transaction_witness_set]
  , transaction_metadata_set   : { * transaction_index => transaction_metadata }
  ]; Valid blocks must also satisfy the following two constraints:
   ; 1) the length of transaction_bodies and transaction_witness_sets must be the same
   ; 2) every transaction_index must be strictly smaller than the length of transaction_bodies

transaction = [transaction_body, transaction_witness_set, [?transaction_metadata]] ; TODO: change maybe encoding

transaction_index = uint

header =
  [ header_body
  , body_signature : $kes_signature
  ]

header_body =
  [ prev_hash        : ($hash32 / null) ; TODO: put in sensible order.  group prev_hash with slot and block number.
  , issuer_vkey      : $vkey
  , vrf_vkey         : $vrf_vkey
  , slot             : uint
  , nonce_vrf        : $vrf_cert
  , leader_vrf       : $vrf_cert
  , block_body_size  : uint
  , block_number     : uint
  , block_body_hash  : $hash32 ; merkle triple root
  , operational_cert
  , protocol_version
  ]

operational_cert =
  ( hot_vkey        : $kes_vkey
  , sequence_number : uint
  , kes_period      : uint
  , sigma           : $signature
  )

protocol_version = (uint, uint)

transaction_body =
  { 0 : set<transaction_input>
  , 1 : [* transaction_output]
  , 2 : coin ; fee
  , 3 : uint ; ttl
  , ? 4 : [* certificate]
  , ? 5 : withdrawals
  , ? 6 : update
  , ? 7 : metadata_hash
  }

transaction_input = [ transaction_id : $hash32
                    , index : uint
                    ]

transaction_output = [address, amount : uint]

; TODO:
; address = bytes .size ???
; custom binary format
; [TTTT--------------------------------------------]
; 
; first byte: tag


; 0000: base address: keyhash,keyhash
; 0001: base address: keyhash,scripthash
; 0010: base address: scripthash,keyhash
; 0011: base address: scripthash,scripthash
; 0101: pointer address: keyhash, 3 variable length uint
; 0110: pointer address: scripthash, 3 variable length uint
; 0111: enterprise address:
; 1000: byron address ; 10000010
; 1001 - 1111: new formats


address =
 (  0, addr_keyhash, addr_keyhash       ; base address
 // 1, addr_keyhash, scripthash    ; base address
 // 2, scripthash, addr_keyhash    ; base address
 // 3, scripthash, scripthash ; base address
 // 4, addr_keyhash, pointer       ; pointer address
 // 5, scripthash, pointer    ; pointer address
 // 6, addr_keyhash                ; enterprise address (null staking reference)
 // 7, scripthash             ; enterprise address (null staking reference)
 // 8, addr_keyhash                ; bootstrap address
 )
pointer = (uint, uint, uint)

certificate =
  [  0, stake_credential                   ; stake registration
  // 1, stake_credential                   ; stake deregistration
  // 2, stake_credential, pool_keyhash     ; stake delegation
  // 3, pool_params                        ; pool registration
  // 4, pool_keyhash, epoch                ; pool retirement
  // 5, genesishash, genesis_delegate_hash ; genesis key delegation
  // 6, move_instantaneous_reward          ; move instantaneous rewards
  ]

move_instantaneous_reward = { * stake_credential => coin }

stake_credential =
  [  0, addr_keyhash
  // 1, scripthash
  ]

pool_params = ( pool_keyhash        ; operator
              , vrf_keyhash         ; vrf keyhash
              , coin                ; pledge
              , coin                ; cost
              , unit_interval       ; margin
              , stake_credential    ; reward account
              , set<addr_keyhash>   ; pool owners
              , [* relay]           ; relays
              , [?pool_metadata]    ; pool metadata ; TODO: change maybe encoding
              )


relay = [ port: uint / null
        , dnsname: tstr .size (0..64)
        / ipv4: bytes .size 4
        / ipv6: bytes .size 16
        ]


pool_metadata = [url, metadata_hash]
url = tstr .size (0..64)

withdrawals = { * stake_credential => coin }

update = [ proposed_protocol_parameter_updates
         , epoch
         ]

proposed_protocol_parameter_updates =
  { * genesishash => protocol_param_update }

protocol_param_update =
  { ? 0:  uint               ; minfee A
  , ? 1:  uint               ; minfee B
  , ? 2:  uint               ; max block body size
  , ? 3:  uint               ; max transaction size
  , ? 4:  uint               ; max block header size
  , ? 5:  coin               ; key deposit
  , ? 6:  unit_interval      ; key deposit min refund
  , ? 7:  rational           ; key deposit decay rate
  , ? 8:  coin               ; pool deposit
  , ? 9:  unit_interval      ; pool deposit min refund
  , ? 10: rational           ; pool deposit decay rate
  , ? 11: epoch              ; maximum epoch
  , ? 12: uint               ; n_optimal. desired number of stake pools
  , ? 13: rational           ; pool pledge influence
  , ? 14: unit_interval      ; expansion rate
  , ? 15: unit_interval      ; treasury growth rate
  , ? 16: unit_interval      ; active slot coefficient
  , ? 17: unit_interval      ; d. decentralization constant
  , ? 18: $nonce             ; extra entropy
  , ? 19: [protocol_version] ; protocol version
  }

transaction_witness_set =
  { ?0 => [* vkeywitness ]
  , ?1 => [* multisig_script ]
  ; , ?2 => [* monetary_policy_script ]
  ; , ?3 => [* plutus_script ]
  }

transaction_metadatum =
    { * transaction_metadatum => transaction_metadatum }
  / [ * transaction_metadatum ]
  / int
  / bytes .size 64
  / text .size 64

transaction_metadadum_label = uint

transaction_metadata = { * transaction_metadadum_label => transaction_metadatum }


vkeywitness = [ $vkey, $signature ]

multisig_script =
  [  0, addr_keyhash                 ; public key
  // 1, [ * multisig_script ]        ;  TODO:one of these is and and the other is or
  // 2, [ * multisig_script ]        ; 
  // 3, uint, [ * multisig_script ]  ; n of k
  ]

coin = uint
epoch = uint

addr_keyhash = $hash28
scripthash = $hash28

genesis_delegate_hash = $hash32
pool_keyhash = $hash32
genesishash = $hash32
metadata_hash = $hash32
vrf_keyhash = $hash32
